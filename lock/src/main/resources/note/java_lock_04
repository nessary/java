

  关于双重校验
  jdk版本<1.5 ==> 对构造函数的赋值 没有增强 是三步操作(申请工作内存，执行init() 再进行赋值) 会发生JIT优化


  jdk 1.7 ==> 更改了 优化标准 并且优化了synchronized的执行顺序导致 执行更快 所以JIT内部一步操作被禁止(如果锁的是类的
      属性 则不会发生重排序)
       ===> 这里会发生网上说的那种 分配内存 使用volatile去解决的原因是使用了临时变量的形式 进行替换

  jdk1.8 ==> 修正了synchronized的执行准则 保证锁的对象 是单个执行 但是JAVA是抢占式资源的方式 所以他会被执行JIT优化
        具体恢复原因是(增强编译速度) 这里的话如果还是jdk 1.7的代码 会发生重排序 但是 这种概率很小 因为synchronized
         会把当前 A=new A()快速编译排序 因为只有一段代码 执行的时候被排的概率比较小(JDK1.8的增强)

